(* monae: Monadic equational reasoning in Coq                                 *)
(* Copyright (C) 2023 monae authors, license: LGPL-2.1-or-later               *)
Require Import ZArith.
From mathcomp Require Import all_ssreflect.
From mathcomp Require boolp.
From infotheo Require Import ssrZ.
Require Import monad_model.
From HB Require Import structures.
Require Import preamble hierarchy monad_lib typed_store_lib.

(******************************************************************************)
(*                         Typed store examples                               *)
(*                                                                            *)
(*  Inductive ml_type == generated by coqgen                                  *)
(*                                                                            *)
(*  Module MLTypesNat                                                         *)
(*    coq_type_nat          == adapted from code generated by coqgen          *)
(*    coq_type_nat0         == coq_type_nat with identity monad               *)
(*    Definition cycle                                                        *)
(*    Fixpoint fact_ref                                                       *)
(*    Definition fact_for                                                     *)
(*    Fixpoint fibo_ref                                                       *)
(*                                                                            *)
(*  Module MLtypes63                                                          *)
(*    Fixpoint coq_type63   == generated type translation function            *)
(*    Definition fact_for63                                                   *)
(******************************************************************************)

Local Open Scope monae_scope.

(******************************************************************************)
(*                             generated by coqgen                            *)
(******************************************************************************)
Module MLTypes.
Inductive ml_type : Set :=
  | ml_int
  | ml_bool
  | ml_unit
  | ml_ref (_ : ml_type)
  | ml_arrow (_ : ml_type) (_ : ml_type)
  | ml_rlist (_ : ml_type).

Definition ml_type_eq_dec (T1 T2 : ml_type) : {T1=T2}+{T1<>T2}.
revert T2; induction T1; destruct T2;
  try (right; intro; discriminate); try (now left);
  try (case (IHT1_5 T2_5); [|right; injection; intros; contradiction]);
  try (case (IHT1_4 T2_4); [|right; injection; intros; contradiction]);
  try (case (IHT1_3 T2_3); [|right; injection; intros; contradiction]);
  try (case (IHT1_2 T2_2); [|right; injection; intros; contradiction]);
  (case (IHT1 T2) || case (IHT1_1 T2_1)); try (left; now subst);
    right; injection; intros; contradiction.
Defined.

Definition val_nonempty (M : UU0 -> UU0) := tt.

Notation loc := (@loc _ monad_model.locT_nat).

Inductive rlist (a : Type) (a_1 : ml_type) :=
  | Nil
  | Cons (_ : a) (_ : loc (ml_rlist a_1)).

Definition ml_type_eq_mixin := hasDecEq.Build _ (comparePc MLTypes.ml_type_eq_dec).
HB.instance Definition ml_type_eqType := ml_type_eq_mixin.

End MLTypes.
(******************************************************************************)

Module CoqTypeNat.
Import MLTypes.

Section with_monad.
Context [M : Type -> Type].

Fixpoint coq_type_nat (T : ml_type) : Type :=
  match T with
  | ml_int => nat
  | ml_bool => bool
  | ml_unit => unit
  | ml_arrow T1 T2 => coq_type_nat T1 -> M (coq_type_nat T2)
  | ml_ref T1 => loc T1
  | ml_rlist T1 => rlist (coq_type_nat T1) T1
  end.
End with_monad.

HB.instance Definition _ := @isML_universe.Build ml_type coq_type_nat ml_unit val_nonempty.
